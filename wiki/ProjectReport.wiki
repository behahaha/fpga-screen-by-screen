#summary This page includes our Written Project Report for A Game of Blocks.


= Details =
*Problems and Solutions:*
 	Our goal for the ECE 287 project is to create “A Game of Blocks”- a collection of retro mini games including a Player-versus-Environment mode, a Player-versus-Player mode, and a maze mode. To create these, we knew we would have to learn much more about the workings of Verilog and the FPGA. Starting out, we knew we would have to display images on a monitor, control movement using user input, and display scores using counters.
 	As we started working with the FPGA, we encountered several problems. Our largest obstacle was learning to use the VGA out on the FPGA board. In John Loomis’s vgalab2 VGA driver, we saw that there had to be several different modules all working for the VGA to successfully present an image, text, or any other kind of data. These modules included vga_sync.v, char_rom.v, chars.v, VGA_Audio_PLL.v, and textbox.v.
 	 After experimentation with the code (commenting some sections out and changing some numerical values), we learned that we were able to create a sort of “background-foreground” using pixel colors. This system allowed us to create a two-color game, where the player and walls are one color, and the background, or areas to indicate moveable space, are another color. We found two variables, “px” and “py” that acted as x and y coordinates of the screen. These allowed us to define where different areas and objects were located.
 	The block’s movement came later. We knew that objects were defined by being within certain pairs of x and y coordinates, so we thought “Why can’t we define a value that we can change?” Our first trial of the block’s movement was simply adding 50 to the pixel x or y coordinate if a switch was thrown. This resulted in the block jumping from one point to another, and then back when the switch was placed low. We realized that, with help from the clock, we could make the block shift in any direction at a set speed, as long as a switch was thrown high.
 	As a result of our struggles with the VGA, we learned how to “paint” walls and objects using pixel assignments. We also learned how to manipulate those assignments to create movement. These would be the most valuable lessons learned in the early stages of our project.
 	As we worked more with the game’s design, we began to find areas in which we could improve the playability. We found the University of Toronto’s PS2 keyboard driver, which would show us a numerical value on the FPGA’s hexadecimal displays. As the arrow keys were pressed, we saw each had a unique, unchanging value. This allowed us to change our game to accept the keyboard control, and helped A Game of Blocks become much more user-friendly.


*Background:*
 	John Loomis created his vgalab2 project to serve in displaying text to a VGA monitor. This approach is much more familiar to the average computer user because we are used to seeing text and images displayed on our own computers. While this is a very useful tool, we decided that we would take this tool in a different direction. We removed the code Loomis used for his text and replaced it with a “color-by-number” setup using pixel coordinates. Where Loomis’s code is more like writing a word on a piece of paper, ours is more like coloring in squares on a piece of graphing paper to create an image. In each of our separate levels, the player will see walls and blocks and moving enemies, and these are all created by assigning different colors to groups of pixels.

*Low-Level Description:*
	Our original idea was to create a spinoff of Mario where we would create a space in which the view would scroll from left to right as the player moved. However, we soon discovered problems with our understanding of the VGA and decided it would be in our best interest to have a less ambitious goal. Our inspiration came from the old Atari game, “Adventure”. In this game, a player would move around as a single block. The player had various tasks, like finding weapons, slaying dragons, finding keys for locked dungeons, and finding treasure.
 	One of the most enlightening points in our design project was learning how game designers created walls. In the maze mode, this feature is crucial because what is the point of a maze when you can walk through colored lines that are supposed to be walls? We solved this problem simply by saying, “OK, block. If your coordinates are this, you will move this way, or if your coordinates are that, you will move that way.” We had to consider every side of every surface, deciding how to create these statements to prevent left movement into the right edge side of a barricade, or upward movement into the bottom edge of a barricade. This gave us an enormous appreciation for video game designers, seeing just how much work it took to ensure the laws of physics would apply when confronted with a solid human impacting a solid wall. Our games are only 480x640 pixels, so simply saying, “player, you can’t go in these 100 pixels” is nothing compared to the larger, modern games like Call of Duty or Battlefield.
 	Our game is basic, but because of it being so basically designed, the major functions of player movement and obstruction from barriers is easily modified. All that would be required for someone to change a maze layout is to go in the code in “mazescreen.v” and look for “Painting the maze walls” and “Creating the wall barriers”. Changing numbers in these two sections of the code will change the layout of the maze by only one barrier per number or pair of numbers changed, but this can be extended to any amount of walls and barriers.

*Manual:*

*Basics:*
 	Welcome to A Game of Blocks! Here, you will play various games using the Altera DE2 FPGA, and a PS2 keyboard. Depending on which game you would like to play, you will need to throw a switch “high” to activate that level. The level selection is listed on the in-game welcome screen. Be sure to use only ONE of these switches at a time, or you may find yourself running into invisible walls! At the beginning of every level, you must begin by throwing the reset switch (SW[4]) high. This will start the level and enable movement. If, at any time, you wish to start the level over, simply turn this switch “low” then “high” again.
*Maze:*
 	In the maze mode, the player will start in the lower left hand corner of the maze. The object is to maneuver the maze using the keyboard’s arrow keys. Tick marks will appear as time expires as a record of the player’s time in the maze. The goal is to reach “END” as quickly as possible. Once you finish, count up your tick marks and compare with your friends! Who can finish the maze fastest? Hint: you may want to check some of the walls, there may be a secret shortcut!
*PvE:*
 	In the PvE mode, the player will spawn in the upper left hand corner of the maze. The objective is to strike the evil enemy blocks with your sword in order to gain points, and lives. Every three kills, your amount of lives will increment by one. However, with every kill the enemies will become faster. If an enemy strikes the back or sides of your block, you will lose a life. If your lives reach zero, your score will reset to zero, and the level will reset. Who can last the longest? Only the fastest will survive!
*PvP:*
 	In the PvP mode, the player will be required to find a friend with an FPGA and interconnect the two using ribbon cables. Once this is done, and both players have their boards programmed and keyboards and monitors at the ready, the game can begin. Both players must select the PvP mode, and throw the reset switch “high” in order to begin gameplay. Players will spawn apart from each other, both armed with swords. The objective is to strike the other player’s sides or back with your sword. When this happens, the striker’s score will increment by one and the victim will lose one life.
*Conclusion:*
 	We began this project envisioning a basic game that would only include a maze mode and a PvE game After quickly learning about the Loomis VGA controls, it was simple for us to create any kind of level we desired. The maze reached its limitation at this point, because making complex mazes would only require multiple more lines of careful coding. The PvE has much room to grow and become more polished. The basics of PvE include player motion, enemy motion toward the player (done with a series of if statements, where the enemy will move up if it is below the player, will move left if it is right of the player. 
 	Once we learned how to create enemy movement, we expanded on the PvE concept, granting points to the player who “kills” the enemies (moves so the player’s sword is touching the enemy). This is also expanded upon where if the player is hit from behind by an enemy, the player will lose a life. 